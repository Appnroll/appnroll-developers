# General

## Prettier, Linter and other automatic tools

Most convention you'll find in this guide requires some manual, intentional effort from programmer. Thankfully all other
stuff that's not included is hidden in automatic tools configuration. Most of those configs are the tools' defaults
with some notable exceptions you'll find reading this guide.

# Files and modules organisation

## Files naming convention

When naming files, you need to remember about few things.
- Use the kebab case convention so the filename will look like it's a part of the URL. We're web devs after all.
- Usually add a file type suffix informing what type of file it is (e.g `.component`). That way it'll be easier to find
  the file you need.
- Name the file the same as the main (default) export.

The available file type suffixes (list is non-exhaustive):
- `.component` for React components,
- `.stories` for files holding Storybook stories,
- `.test` for unit tests,
- `.e2e` for end-to-end tests,
- `.fragment` for GraphQL fragments,
- `.interface` for interfaces,
- `.request` for modules exposing an HTTP request,
- `.fixture` for data used in tests.

There are some modules that doesn't need that suffix. It usually happen when the filename is important (like in the
`/pages` folder in Gatsby projects) or the exported value is a function (then `.function` suffix would be redundant, as
the module name alone would inform it's a function, eg. `get-some-data.ts`).

### Examples

```ts
contact-form.component.tsx
contact-form-component.stories.tsx
contact-form-component.test.tsx
contact-form-component.e2e.tsx
user-profile.fragment.ts
user-profile.interface.ts
get-user-profile.request.ts
parse-user-profile.ts
```

## Folders structure and files organisation

Keep the related files in one catalogue for ease of finding the relation and working on a single module.

### Examples

```typescript
├── button
│   ├── button.component.tsx
│   ├── button-component.test.tsx
│   ├── button-component.stories.tsx
│   └── button-content.interface.ts
```

## Avoid index files

Do not create `index` files that reexport values from files inside a catalogue. They add unnecessary work that needs to
be done and checked for correctness, as well as it needs to be kept in sync in case new exports will show up.

# Style

## Use two spaces

It keeps a healthy balance of readability in your code editor and in GitHub code review screen.

_Configured in Prettier._

## Keep the line width to 80 characters

This makes it much simpler to work on multiple files at once open in adjacent tabs. It also helps during code review
as the code won't soft-wrap in unexpected places (when you're using split view).

_Configured in Prettier._

## Don't use semicolons

Keep the code clean and avoid adding unnecessary semicolons.

_Configured in Prettier._

## Use double quotes or template strings

Avoid using single quotes. Double quotes are required by HTML and are a default JSX convention so it keeps everything
consistent.

_Configured in Prettier._

## Use verbs for functions

Whenever creating a function, prefix it with an actionable verb so that it's obvious for anyone using that value
that it needs to be called. It's also easier to understand the effect of calling cuch

### Examples

```typescript
// Good.
const isActive = something => something.active // => true
const activate = something => something.active = true
const greet = () => alert("hello!")

// Bad.
const openHandler = () => ... // Obvious where to use but not obvious what will happen.
const activator = () => ... // Not obvious what will happen.
const onClick = () => alert("hello!")
```

## Use adjectives for boolean values

Use adjectives or similar form for boolean values. Do not use the `is` prefix for non-functional values. Try to keep
it similar to what HTML does (active, disabled, etc.).

### Examples

```typescript
// Good.
const open = true
const selected = false
const inTransition = true

// Bad.
const isOpen = true
const selection = false
```

## Avoid !! ("double bang")

It's an obscure way of converting a value to a boolean. It's easily mistaken with a plain negation and requires
more mental capacity to properly understand. Prefer simple and explicit `Boolean(value)` or don't convert at all
as it's usually not required.

### Examples

```typescript
// Good.
const booleanValue = Boolean("hello")

// Bad.
const supposedlyBooleanValue = !!"hello"
```

## Use screaming case for global constants

When you expose some constant values globally in the app (either by exporting it or using it as a static class property),
use the SCREAMING_CASE to inform consumers that value is not a part of the module and is not meant to be changed by
code. Immutability should be ensured within a reason. The convention is native to JavaScript.

### Examples

```typescript
// Basic configuration value.
export const COMMENTS_COUNT = 10

// Component allowing to access its default config.
export class Slider {
  public static readonly DEFAULT_COUNT = 5
}

// Native object's global value.
Number.MAX_SAFE_INTEGER
```

# Code

## Component's module structure

Keep all important pieces that create a full component definition in one place. Splitting those parts in separate
files brings chaos and makes it harder to understand the full functionality at a glance. You'd have to keep multiple
files open and manage the tabs clutter to work on a single piece of code.

### Example

```typescript
/* Good. Everything in one place. */
interface MyComponentProps {
  hello: string
}
const Component: AppFunctionComponent<MyComponentProps> = () => { ... }
export default Component

/* Bad. Have to keep an eye at multiple files. */

// my-component.interface.ts
interface MyComponentProps {
  hello: string
}

// my-component.component.ts
const Component: AppFunctionComponent<MyComponentProps> = () => { ... }
export default Component
```

## Creating components

Prefer function components over class components for the smaller code-print. Use the `AppFunctionComponent` interface
to type the component. Declare it as a constant and then export that constant as a default export of the module. Keep
only a single component in a file (with an exception of styled components that makes up the main component).

### Example

```typescript
const MyComponent: AppFunctionComponent<Props> = () => {
  return <div />
}

export default MyComponent
```

## Component's properties

Declare the component's properties as the `Props` interface and use it in the AppFunctionComponent generic type.
Destructure the properties in the parameters declaration and provide default values for optional properties there
(if it makes sense for a prop to have a default).

### Example

```typescript
interface Props {
  property: string
  optionalProperty?: number
}

const MyComponent: AppFunctionComponent<Props> = ({ property, optionalProperty = 42 }) => {
  return (
    <div>
      {property}: {optionalProperty}
    </div>
  )
}
```

## Don't use arrow return

Prefer braces in the component, rather than arrow return to avoid potentially massive and unrelated diffs when
component will require more stuff in the body later in the game.

### Example

```typescript
// Good.
const MyComponent: AppFunctionComponent = () => {
  return <div />
}

// Bad. Will create a big diff when changed.
const MyComponent: AppFunctionComponent = () => <div />
```

## Hooks

## AppFunctionComponent and its extensions

`AppFunctionComponent` interface is a basic component type in all of our applications. On top of extending the React's
`FunctionComponent` it provides two additional benefits:

- it makes all the properties on the root lever `readonly` to prevent their accidental modification,
- it adds `className: string` property so that all components will be easily stylable.

When the app have some other specific properties that all components can use, then extend the `AppFunctionComponent`
rather than creating a new name variant to avoid confusion for developers working on other apps.

```typescript
// Base AppFunctionComponent
interface AppFunctionComponent<P = {}>
  extends FunctionComponent<Readonly<P & { className?: string }>> {}

// Extended interface
interface IntlProps {
  intl: (label: string) => string
}

interface AppFunctionComponent<P = {}>
  extends FunctionComponent<Readonly<P & { className?: string } & IntlProps>> {}
```

## Styling components

Don't export styled components unnecessarily.

If you need them in multiple files, then maybe you need a separate file for that component.


```typescript
const HeaderRoot = styled.header`
  background: red
`

const Header: AppFunctionComponent = () => {
  return (
    <HeaderRoot>App'n'roll</HeaderRoot>
  )
}

export default Header
```

## Smart adn dumb

contact-form & contact-form-ui

## Avoid `any`

But not at any cost. Try to figure out the expected type of a value and type it properly so that you and your fellow
programmers will get the benefit of type safety and IDE support.

In rare cases, when type is difficult to use, you can use an explicit `any`. But keep in mind you might get a change
request in code review if the type was not that complex.

# Tests

## Test filenames convention

For unit tests use the `.test.ts(x)` suffix and for end-to-end tests use `.e2e.ts(x)`. That way they'll be easy
to find in the component's catalogue.

### Examples

```typescript
button.test.tsx
checkout.e2e.tsx
```

## writing tests

on root, test("x works"), no "should"

## Use `test`

When declaring a test use the `test` function (instead of `it`). It nicely feet into tests (it's a `test` after all).

### Examples

```typescript
// Good.
test("writes good tests", () => ...)

// Bad. (Well, not really, but still…)
it("doesn't write good tests", () => ...)
```

## You should not `should`

Keep tests simple. "Works" is enough. We know it should.

### Examples

```typescript
// Good.
test("works when clicked", () => ...)

// Bad.
test("should work when clicked", () => ...)
```

## Expose custom getters in the renderer when necessary

### Examples

```typescript
const renderMyComponent = () => {
  const outcome = render(<MyComponent />)
  return {
    ...outcome,
    getButton: () => outcome.getByRole("button")
  }
}

test("clicking a button does something", () => {
  const { getButton } = renderMyComponent()
  // ...
})
```

## Use arrow function as a callback

Use only arrow functions in the test's callback. Don't use function expression or a reference.

### Examples

```typescript
// Good.
test("with good callback", () => ...)

// Bad.
test("with bad callback", function() { ... })
```

## Don't use root level `describe`

The module's name is enough to find a test and know what it is.

### Examples

```typescript
// Bad.
describe("MyComponent test", () => {
  test("", () => ...)
})

// Good. (Just test.)
test("", () => ...)
```

# Stories
