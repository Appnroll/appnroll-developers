# General

## Prettier, Linter and other automatic tools

Most convention you'll find in this guide requires some manual, intentional effort from programmer. Thankfully all other
stuff that's not included is hidden in automatic tools configuration. Most of those configs are the tools' defaults
with some notable exceptions you'll find reading this guide.

# Files and modules organisation

## Files naming convention

When naming files, you need to remember about few things.
- Use the kebab case convention so the filename will look like it's a part of the URL. We're web devs after all.
- Usually add a file type suffix informing what type of file it is (e.g `.component`). That way it'll be easier to find
  the file you need.
- Name the file the same as the main (default) export.

The available file type suffixes (list is non-exhaustive):
- `.component` for React components,
- `.stories` for files holding Storybook stories,
- `.test` for unit tests,
- `.e2e` for end-to-end tests,
- `.fragment` for GraphQL fragments,
- `.interface` for interfaces,
- `.request` for modules exposing an HTTP request.

There are some modules that doesn't need that suffix. It usually happen when the filename is important (like in the
`/pages` folder in Gatsby projects) or the exported value is a function (then `.function` suffix would be redundant, as
the module name alone would inform it's a function, eg. `get-some-data.ts`).

### Examples

```ts
contact-form.component.tsx
contact-form-component.stories.tsx
contact-form-component.test.tsx
contact-form-component.e2e.tsx
user-profile.fragment.ts
user-profile.interface.ts
get-user-profile.request.ts
parse-user-profile.ts
```

## Folders structure and files organisation

# Style

- 80 columns
- no semicolons
- ...

# Code

## Creating components

Prefer function components over class components for the smaller code-print. Use the `AppFunctionComponent` interface
to type the component. Declare it as a constant and then export that constant as a default export of the module. Keep
only a single component in a file (with an exception of styled components that makes up the main component).

### Example

```typescript
const MyComponent: AppFunctionComponent<Props> = () => {
  return <div />
}

export default MyComponent
```

## Component's properties

Declare the component's properties as the `Props` interface and use it in the AppFunctionComponent generic type.
Destructure the properties in the parameters declaration and provide default values for optional properties there
(if it makes sense for a prop to have a default).

### Example

```typescript
interface Props {
  property: string
  optionalProperty?: number
}

const MyComponent: AppFunctionComponent<Props> = ({ property, optionalProperty = 42 }) => {
  return (
    <div>
      {property}: {optionalProperty}
    </div>
  )
}
```

## Don't use arrow return

Prefer braces in the component, rather than arrow return to avoid potentially massive and unrelated diffs when
component will require more stuff in the body later in the game.

### Example

```typescript
// Good.
const MyComponent: AppFunctionComponent = () => {
  return <div />
}

// Bad. Will create a big diff when changed.
const MyComponent: AppFunctionComponent = () => <div />
```

## Hooks

## AppFunctionComponent and its extensions

`AppFunctionComponent` interface is a basic component type in all of our applications. On top of extending the React's
`FunctionComponent` it provides two additional benefits:

- it makes all the properties on the root lever `readonly` to prevent their accidental modification,
- it adds `className: string` property so that all components will be easily stylable.

When the app have some other specific properties that all components can use, then extend the `AppFunctionComponent`
rather than creating a new name variant to avoid confusion for developers working on other apps.

```typescript
// Base AppFunctionComponent
interface AppFunctionComponent<P = {}>
  extends FunctionComponent<Readonly<P & { className?: string }>> {}

// Extended interface
interface IntlProps {
  intl: (label: string) => string
}

interface AppFunctionComponent<P = {}>
  extends FunctionComponent<Readonly<P & { className?: string } & IntlProps>> {}
```

## Styling components

Don't export styled components unnecessarily.

If you need them in multiple files, then maybe you need a separate file for that component.


```typescript
const HeaderRoot = styled.header`
  background: red
`

const Header: AppFunctionComponent = () => {
  return (
    <HeaderRoot>App'n'roll</HeaderRoot>
  )
}

export default Header
```

## Smart adn dumb

contact-form & contact-form-ui

# Tests

## filename convention

.test.ts, e2e.ts

## writing tests

on root, test("x works"), no "should"

# Stories
